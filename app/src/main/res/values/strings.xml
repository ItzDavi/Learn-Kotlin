<resources>
    <string name="app_name">LearnKotlin</string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="itzdavilink">Instagram:\n\<a href="https://www.instagram.com/davidepuntomolo/">@davidepuntomolo</a></string>
    <string name="svarionlink">Instagram:\n\<a href="https://www.instagram.com/svi_ale91/">@svi_ale91</a></string>
    <string name="itzdavigitlink">Projects:\n\<a href="https://www.github.com/ItzDavi/">GitHub.com/ItzDavi</a></string>
    <string name="svariongitlink">Projects:\n\<a href="https://www.github.com/svarion1/">GitHub.com/Svarion1</a></string>

    <!-- Lessons Strings -->
    <string name="lesson1_1">Kotlin is a statically typed programming language that runs on the Java Virtual Machine and also can be compiled to JavaScript source code or use the LLVM compiler infrastructure. Kotlin is developed by JetBrains, the company behind IntelliJ IDEA, the most popular Java IDE.</string>
    <string name="kotlin_1_a">Kotlin is a general purpose, free, open source, statically typed pragmatic programming language. At first glance, Kotlin looks like a more concise and streamlined version of Java. Functions are defined with the fun keyword, and that semicolons are now optional when newlines are present.</string>
    <string name="kotlin_1_b">Many asynchronous mechanisms available in other languages can be implemented as libraries using Kotlin coroutines. This includes async/await from C#.</string>
    <string name="kotlin_2_a">In the top row, click the Empty Activity template to select it as the template for your project. The Empty Activity template is the simplest template that can be used to create an app. It has a single screen and displays a simple "Hello World!" message.</string>
    <string name="kotlin_2_b">When you first open Android Studio, you\'ll see three windows:(1) The Project window shows the files and folders of your project.(2) The Editing window is for editing code.(3) The What\'s New window shows news and useful tips.</string>
    <string name="variables_1_a">When you decide what aspects of your app can be variable, it\'s important to specify what type of data can be stored in those variables. In Kotlin, there are some common basic data types, like Int, String, Boolean, Double and Float. </string>
    <string name="variables_1_b">In Kotlin, everything is an object in the sense that you can call member functions and properties on any variable.</string>
    <string name="variables_2_a">Read-only local variables are defined using the keyword val. They can be assigned a value only once. Variables that can be reassigned use the var keyword.</string>
    <string name="variables_2_b">When you define a variable, you assign a name to uniquely identify it. You also decide what type of data it can hold by specifying the data type.</string>
    <string name="variables_3_a">The lateinit lets you defer property initialization. When using lateinit, you should initialize your property as soon as possible.</string>
    <string name="variables_3_b">private means that the member is visible inside this class only (including all its members).</string>
    <string name="activities_1_a">An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI </string>
    <string name="activities_1_b"> While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows, Multi-Window mode or embedded into other windows.</string>
    <string name="activities_2_a">Activities in the system are managed as activity stacks. When a new activity is started, it is usually placed on the top of the current stack and becomes the running activity.</string>
    <string name="activities_2_b">To navigate transitions between stages of the activity lifecycle, the Activity class provides a core set of six callbacks: onCreate(), onStart(), onResume(), onPause(), onStop(), and onDestroy(). The system invokes each of these callbacks as an activity enters a new state.</string>
    <string name="activities_3_a">To declare your activity, open your manifest file and add an activity element as a child of the application element. The only required attribute for this element is android:name, which specifies the class name of the activity. </string>
    <string name="activities_3_b">Most apps contain multiple screens, which means they comprise multiple activities. Typically, one activity in an app is specified as the main activity, which is the first screen to appear when the user launches the app. Each activity can then start another activity in order to perform different actions.</string>
    <string name="conditions_1_a">Conditionals are commands in programming languages that handle decisions. With conditionals, code is dynamic, which means that it can behave differently given a different condition.</string>
    <string name="conditions_1_b">To use if statements, you need to use the if keyword followed by the condition that you want to evaluate. You need to express the condition with a boolean expression.</string>
    <string name="conditions_2_a">In Kotlin, when you deal with multiple branches, you can use the when statement instead of the if/else statement because it improves readability, which refers to how easy it is for human readers, typically developers, to read the code.</string>
    <string name="conditions_2_b">A when statement accepts a single value through the parameter. The value is then evaluated against each of the conditions sequentially. The corresponding body of the first condition that\'s met is then executed. Each condition and body are separated by an arrow.</string>
    <string name="conditions_3_a">A Ternary operator is the only conditional operator that takes three operands. Java ternary operator is a one liner replacement for if-then-else statement and used a lot in java programming.</string>
    <string name="conditions_3_b">The first operand in java ternary operator should be a boolean or a statement with boolean result. If the first operand is true then java ternary operator returns second operand else it returns third operand.</string>
    <string name="loops_1_a">The for loop iterates through anything that provides an iterator. This is equivalent to the foreach loop in languages like C#.</string>
    <string name="loops_1_b">A for loop over a range or an array is compiled to an index-based loop that does not create an iterator object. If you want to iterate through an array or a list with an index, you can do it this way: for (i in array.indices)</string>
    <string name="loops_2_a">while and do-while loops execute their body continuously while their condition is satisfied.</string>
    <string name="loops_2_b">while checks the condition and, if it\'s satisfied, executes the body and then returns to the condition check. do-while executes the body and then checks the condition. If it\'s satisfied, the loop repeats. So, the body of do-while executes at least once regardless of the condition.</string>
    <string name="layouts_1_a">A layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of View and ViewGroup objects. A View usually draws something the user can see and interact with. </string>
    <string name="layouts_1_b">Whereas a ViewGroup is an invisible container that defines the layout structure for View and other ViewGroup objects, as shown in figure 1. The View objects are usually called "widgets" and can be one of many subclasses, such as Button or TextView. The ViewGroup objects are usually called "layouts" can be one of many types that provide a different layout structure, such as LinearLayout or ConstraintLayout .</string>
    <string name="layouts_2_a">Using Android\'s XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way you create web pages in HTML — with a series of nested elements.</string>
    <string name="layouts_2_b">Each layout file must contain exactly one root element, which must be a View or ViewGroup object. Once you\'ve defined the root element, you can add additional layout objects or widgets as child elements to gradually build a View hierarchy that defines your layout.</string>
    <string name="layouts_3_a">ConstraintLayout allows you to create large and complex layouts with a flat view hierarchy. You can build your layout with ConstraintLayout entirely by drag-and-dropping instead of editing the XML. </string>
    <string name="layouts_3_b">To define a view\'s position in ConstraintLayout, you must add at least one horizontal and one vertical constraint for the view. Each constraint represents a connection or alignment to another view, the parent layout, or an invisible guideline</string>
    <string name="events_1_a">On Android, there\'s more than one way to intercept the events from a user\'s interaction with your application. An event listener is an interface in the View class that contains a single callback method. Included in the event listener interfaces are the following callback methods: </string>
    <string name="events_1_b">onClick() : This is called when the user either touches the item. \n onLongClick() : This is called when the user either touches and holds the item. onFocusChange() : This is called when the user navigates onto or away from the item onKey() : This is called when the user is focused on the item and presses or releases a hardware key on the device. onCreateContextMenu() : This is called when a Context Menu is being built.  </string>
    <string name="events_2_a">An Intent is a messaging object you can use to request an action from another app component. An Activity represents a single screen in an app. You can start a new instance of an Activity by passing an Intent to startActivity(). The Intent describes the activity to start and carries any necessary data. </string>
    <string name="events_2_b">Intent are the objects which is used in android for passing the information among Activities in an Application and from one app to another also.  Intent facilitate you to redirect your activity to another activity on occurrence of any event. </string>
    <string name="webview_1_a">If you want to deliver a web application (or just a web page) as a part of a client application, you can do it using WebView. A common scenario in which using WebView is helpful is when you want to provide information in your app that you might need to update, such as an end-user agreement or a user guide.</string>
    <string name="webview_1_b">Another scenario in which WebView can help is if your app provides data to the user that always requires an Internet connection to retrieve data, such as email.  It does not include any features of a fully developed web browser, such as navigation controls or an address bar. All that WebView does, by default, is show a web page.</string>
    <string name="webview_2_a">To add a WebView to your app, you can either include the WebView element in your activity layout, or set the entire Activity window as a WebView in onCreate(). To load a web page in the WebView, use loadUrl().</string>
    <string name="webview_2_b">Load the webpage with loadUrl("http://www.example.com")</string>
    <string name="webview_3_a">Webviews and native apps are just incomparable. Native apps can grant the best possible performance ever and they also have the best possible integration with the OS. There is limited access to the functionalities of the device.</string>
    <string name="webview_3_b">When an application depends on the Android WebView it needs to take into consideration that the system updates the component over time.</string>
    <string name="fragments_1_a">A Fragment represents a reusable portion of your app\'s UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments cannot live on their own—they must be hosted by an activity or another fragment. The fragment’s view hierarchy becomes part of, or attaches to, the host’s view hierarchy. </string>
    <string name="fragments_1_b">Fragments introduce modularity and reusability into your activity’s UI by allowing you to divide the UI into discrete chunks. Fragments are better suited to define and manage the UI of a single screen or portion of a screen. Dividing your UI into fragments makes it easier to modify your activity\'s appearance at runtime. </string>
    <string name="fragments_2_a">Each Fragment instance has its own lifecycle. When a user navigates and interacts with your app, your fragments transition through various states in their lifecycle as they are added, removed, and enter or exit the screen. When a fragment is instantiated, it begins in the INITIALIZED state. </string>
    <string name="fragments_2_b">As a fragment progresses through its lifecycle, it moves upward and downward through its states. For example, a fragment that is added to the top of the back stack moves upward from CREATED to STARTED to RESUMED</string>
    <string name="fragments_3_a">Fragments require a dependency on the AndroidX Fragment library. You need to add the Google Maven repository to your project\'s settings.gradle file in order to include this dependency. While your activity is running, you can make fragment transactions such as adding, removing, or replacing a fragment. In your FragmentActivity, you can get an instance of the FragmentManager, which can be used to create a FragmentTransaction.</string>
    <string name="fragments_3_b">The two fragments will be embedded within the main activity of the application and when the button in the first fragment is pressed, the text entered into the EditText view will appear on the TextView of the second fragment.</string>
    <string name="viewbinding_1_a">View binding is a feature that allows you to more easily write code that interacts with views. Once view binding is enabled in a module, it generates a binding class for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout. In most cases, view binding replaces findViewById. </string>
    <string name="viewbinding_1_b">View binding is enabled on a module by module basis. To enable view binding in a module, set the viewBinding build option to true in the module-level build.gradle file.</string>
    <string name="viewbinding_2_a">You can use the binding class whenever you inflate layouts such as Fragment, Activity, or even a RecyclerView Adapter (or ViewHolder). You don’t have to call findViewById when using view binding — instead just use the properties provided to reference any view in the layout with an id.</string>
    <string name="viewbinding_2_b">The root element of the layout is always stored in a property called root which is generated automatically for you. In an Activity’s onCreate method you pass root to setContentView to tell the Activity to use the layout from the binding object. View bindings are Type-safe because properties are always correctly typed based on the views in the layout. So if you put a TextView in the layout, view binding will expose a TextView property. And also Null-safe for layouts defined in multiple configurations. View binding will detect if a view is only present in some configurations and create a @Nullable property.</string>
    <string name="animations_1_a">Animations can add visual cues that notify users about what\'s going on in your app. They are especially useful when the UI changes state, such as when new content loads or new actions become available. Animations also add a polished look to your app, which gives it a higher quality look and feel.</string>
    <string name="animations_1_b">When you want to animate a bitmap graphic such as an icon or illustration, you should use the drawable animation APIs. Usually, these animations are defined statically with a drawable resource, but you can also define the animation behavior at runtime. When you need to change the visibility or position of views in your layout, you should include subtle animations to help the user understand how the UI is changing.</string>
    <string name="animations_2_a">View Animation: This is the simplest animation used in Android. It define the properties of our Views that should be animated using a technique called Tween Animation.It take the following parameters i.e. size, time duration , rotation angle, start value , end value, and perform the required animation on that object.You can  execute the animation by specifying transformations on your View. </string>
    <string name="animations_2_b">Property animations are highly customizable, you can specify the duration, the number of repeats, the type of interpolation, and the frame rate of the animation. The Property Animation system is always preferred for more complex animations. Property animations allow us to animate any property of any object from one value to another over a specified duration. Drawable Animation: This animation allows the user to load drawable resources and display them one frame after another. This method of animation is useful when user wants to animate things that are easier to represent with Drawable resources.</string>
    <string name="animations_3_a">Hello blank fragment</string>
    <string name="animations_3_b">Hello blank fragment</string>
    <string name="animations_4_a">Hello blank fragment</string>
    <string name="animations_4_b">Hello blank fragment</string>


</resources>